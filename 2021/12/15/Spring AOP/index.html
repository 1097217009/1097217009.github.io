

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="安">
  <meta name="keywords" content="">
  <meta name="description" content="1.什么是AOP面向切面编程（AOP）和面向对象编程（OOP）类似，也是一种编程模式。Spring AOP基于AOP编程模式的一个框架，它的使用有效的减少了系统间的重复代码，达到了模块间的松耦合目的。 AOP的全程是“Aspect Oriented Programming”，即面向切面编程，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心核心业务，从而提高了开发效率。 AOP采取">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring AOP">
<meta property="og:url" content="http://example.com/2021/12/15/Spring%20AOP/index.html">
<meta property="og:site_name" content="安的博客">
<meta property="og:description" content="1.什么是AOP面向切面编程（AOP）和面向对象编程（OOP）类似，也是一种编程模式。Spring AOP基于AOP编程模式的一个框架，它的使用有效的减少了系统间的重复代码，达到了模块间的松耦合目的。 AOP的全程是“Aspect Oriented Programming”，即面向切面编程，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心核心业务，从而提高了开发效率。 AOP采取">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7179784-5d499156cfbeba32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="article:published_time" content="2021-12-15T05:17:11.000Z">
<meta property="article:modified_time" content="2021-12-15T05:18:41.893Z">
<meta property="article:author" content="安">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/7179784-5d499156cfbeba32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
  
  <title>Spring AOP - 安的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>An&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Spring AOP">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-15 13:17" pubdate>
        2021年12月15日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.5k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      24 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Spring AOP</h1>
            
            <div class="markdown-body">
              <h1 id="1-什么是AOP"><a href="#1-什么是AOP" class="headerlink" title="1.什么是AOP"></a>1.什么是AOP</h1><p>面向切面编程（AOP）和面向对象编程（OOP）类似，也是一种编程模式。Spring AOP基于AOP编程模式的一个框架，它的使用有效的减少了系统间的重复代码，达到了模块间的松耦合目的。</p>
<p>AOP的全程是“Aspect Oriented Programming”，即面向切面编程，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心核心业务，从而提高了开发效率。</p>
<p>AOP采取横向抽取机制，取代了传统纵向继承体系的重复代码，其应用主要体现在事务处理，日志管理，权限控制，异常处理等方面。</p>
<p>目前最流行的AOP框架有两个，分别为Spring AOP和AspectJ</p>
<p>Spring AOP使用纯java实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类织入增强的代码。</p>
<p>AspectJ是一个基于java语言的AOP框架，从Spring2.0开始，Spring AOP引入了对AspectJ的支持，AspectJ扩展了java语言，提供了一个专门的编译器，在编译时提供横向代码的织入。</p>
<h1 id="2-AOP的相关术语"><a href="#2-AOP的相关术语" class="headerlink" title="2.AOP的相关术语"></a>2.AOP的相关术语</h1><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Joinpoint(连接点)</td>
<td>指那些被拦截到的点，在Spring中，可以被动态代理拦截目标类的方法</td>
</tr>
<tr>
<td>Pointcut(切入点)</td>
<td>指要对哪些Joinpoint进行拦截，即被拦截的拦截点</td>
</tr>
<tr>
<td>Advice(通知)</td>
<td>指拦截到Joinpoint之后要做的事情，即对切入点增强的内容</td>
</tr>
<tr>
<td>Target(目标)</td>
<td>指代理的目标对象</td>
</tr>
<tr>
<td>Weaving(织入)</td>
<td>指把增强代码应用到目标上，生成代理对象的过程</td>
</tr>
<tr>
<td>Proxy(代理)</td>
<td>指生成的代理对象</td>
</tr>
<tr>
<td>Aspect(切面)</td>
<td>切入点和通知的结合</td>
</tr>
</tbody></table>
<p>Advice的类型（增强的时机）</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>概念</th>
</tr>
</thead>
<tbody><tr>
<td>Before</td>
<td>在方法被调用之前执行增强</td>
</tr>
<tr>
<td>After</td>
<td>在方法被调用之后执行增强</td>
</tr>
<tr>
<td>After-running</td>
<td>在方法成功执行之后执行增强</td>
</tr>
<tr>
<td>After-throwing</td>
<td>在方法抛出指定异常后执行增强</td>
</tr>
<tr>
<td>Around</td>
<td>在方法调用的前后执行自定义的增强行为（最灵活的方式）</td>
</tr>
</tbody></table>
<h1 id="3-Spring-AOP的配置方式"><a href="#3-Spring-AOP的配置方式" class="headerlink" title="3.Spring AOP的配置方式"></a>3.Spring AOP的配置方式</h1><p>Spring AOP是基于动态代理的aop框架，这就意味着，要实现目标对象的各个方面，它将创建该对象的代理。使用以下两种方法之一实现：</p>
<p>1.JDK动态代理——-Spring AOP的首选方式。只要目标对象实现至少一个接口，就会使用JDK动态代理</p>
<p>2.CGLib代理——-如果目标对象没有实现接口，则可以使用CGLib代理。</p>
<p>Spring2.0之后，Spring AOP有了两种配置方式、</p>
<p>1.基于XML的方式</p>
<p>2.基于注解@Aspect的方式</p>
<h2 id="1-开启AOP功能"><a href="#1-开启AOP功能" class="headerlink" title="1.开启AOP功能"></a>1.开启AOP功能</h2><p>在XML中配置SpringAOP</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了<br><br>&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-<span class="hljs-keyword">class</span>属性，默认为<span class="hljs-literal">false</span>，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;时，表示使用<span class="hljs-built_in">CGLib</span>动态代理技术织入增强。不过即使proxy-target-<span class="hljs-keyword">class</span>设置为<span class="hljs-literal">false</span>，如果目标类没有声明接口，则spring将自动使用<span class="hljs-built_in">CGLib</span>动态代理。<br></code></pre></td></tr></table></figure>

<p><strong>第二种方式</strong></p>
<p><strong>自定义类来实现Aop</strong></p>
<p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DiyPointcut &#123;<br><br>   <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">before</span>()&#123;<br>       <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;---------方法执行前---------&quot;);<br>  &#125;<br>   <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">after</span>()&#123;<br>       <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;---------方法执行后---------&quot;);<br>  &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure>

<p>去spring中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="hljs-comment">&lt;!--注册bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.DiyPointcut&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--aop的配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;diy&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>       ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>       UserService userService = (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>       userService.add();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>











<p>使用@EnableAspectJAutoProxy注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Config</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>开启上述配置之后，在所有容器中，被AspectJ注解的bean都会被Spring当作是AOP配置类。成为一个Aspect。</p>
<p>@AspectJ注解只能作用于Spring Bean上面，所以要用@AspectJ修饰的类要么是用了@Component注解修饰，要么在XML中配置过。</p>
<p>例如如下的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-配置Pointcut-增强的切入点"><a href="#2-配置Pointcut-增强的切入点" class="headerlink" title="2.配置Pointcut(增强的切入点)"></a>2.配置Pointcut(增强的切入点)</h2><p>Pointcut在大部分地方被翻译成切点，用于定义哪些方法需要被增强或者说需要被拦截。</p>
<p>在Spring中，我们可以认为Pointcut是用来匹配Spring容器中所有满足指定条件的bean的方法</p>
<p>比如下面的写法：(Pointcut和Advice分开)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.service;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointcutConfig</span></span>&#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">poincut</span><span class="hljs-params">()</span></span>&#123;&#125;   <br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>*</code>代表任意返回值，<code>(..)</code>表示零个或多个任意参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span></span>&#123;<br>    <span class="hljs-meta">@Before(&quot;com.kuang.service.PointcutConfig.pointcut&quot;)</span>   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;do&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Pointcut和Advice结合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.config;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationPointcut</span> </span>&#123;<br>   <span class="hljs-meta">@Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行前---------&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行后---------&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint jp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;环绕前&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;签名:&quot;</span>+jp.getSignature());<br>       <span class="hljs-comment">//执行目标方法proceed</span><br>       Object proceed = jp.proceed();<br>       System.out.println(<span class="hljs-string">&quot;环绕后&quot;</span>);<br>       System.out.println(proceed);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>























<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/872d3dbdc2ca">https://www.jianshu.com/p/872d3dbdc2ca</a></p>
<h2 id="3、Spring-AOP-和-AspectJ"><a href="#3、Spring-AOP-和-AspectJ" class="headerlink" title="3、Spring AOP 和 AspectJ"></a>3、Spring AOP 和 AspectJ</h2><p>现在, 让我们在一些维度上讨论 Spring AOP 和 AspectJ —— 例如功能、目标、Weaving（织入）、内部结构、joinpoints 和简单性。</p>
<h4 id="3-1、能力和目标"><a href="#3-1、能力和目标" class="headerlink" title="3.1、能力和目标"></a>3.1、能力和目标</h4><p>简单地说, Spring AOP 和 AspectJ 有不同的目标。</p>
<p>Spring aop 旨在提供一个跨 Spring IoC 的简单的 aop 实现, 以解决程序员面临的最常见问题。<strong>它不打算作为一个完整的 AOP 解决方案</strong> —— 它只能应用于由 Spring 容器管理的 bean。</p>
<p>另一方面, AspectJ 是原始的 aop 技术, 目的是提供完整的 aop 解决方案。它更健壮, 但也比 Spring AOP 复杂得多。还值得注意的是, AspectJ 可以在所有域对象中应用。</p>
<h4 id="3-2、Weaving（织入）"><a href="#3-2、Weaving（织入）" class="headerlink" title="3.2、Weaving（织入）"></a>3.2、Weaving（织入）</h4><p>AspectJ 和 Spring AOP 都使用不同类型的编织, 这会影响它们在性能和易用性方面的行为。</p>
<p>AspectJ 使用三种不同类型的Weaving:</p>
<ol>
<li><strong>编译时 Weaving</strong>: AspectJ 编译器作为输入我们的方面的源代码和我们的应用, 并产生一个织入类文件作为输出；</li>
<li><strong>编译后 Weaving</strong>: 这也称为二进制织入。它是用来织入现有的类文件和 JAR 文件与我们的方面；</li>
<li><strong>加载时间 Weaving</strong>: 这就像前二进制织入, 不同的是织入被推迟, 直到类加载程序加载类文件到 JVM。</li>
</ol>
<p>要了解更多关于 AspectJ 本身的详细信息, 请 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.baeldung.com/aspectj">阅读此文</a>。</p>
<p>当 AspectJ 使用编译时和class文件加载时织入时，Spring AOP 利用运行时织入。</p>
<p>使用运行时编织, 这些方面在使用目标对象的代理执行应用程序时被编织-使用 JDK 动态代理或 CGLIB 代理 (在下一点讨论):</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7179784-5d499156cfbeba32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>image</p>
<h4 id="3-3、内部结构与应用"><a href="#3-3、内部结构与应用" class="headerlink" title="3.3、内部结构与应用"></a>3.3、内部结构与应用</h4><p>Spring aop 是基于代理的 aop 框架。这意味着, 要实现目标对象的各个方面, 它将创建该对象的代理。使用以下两种方法之一实现:</p>
<ol>
<li>JDK 动态代理 —— Spring AOP 的首选方式。只要目标对象实现甚至一个接口, 就会使用 JDK 动态代理；</li>
<li>CGLIB 代理 —— 如果目标对象没有实现接口, 则可以使用 CGLIB 代理。</li>
</ol>
<p>我们可以从 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html%23aop-proxying">官方文档</a> 中了解有关 Spring AOP 代理机制的更多信息。</p>
<p>另一方面, AspectJ 在运行时不做任何事情, 因为类是直接用方面进行编译的。</p>
<p>与 Spring AOP 不同, 它不需要任何设计模式。为了编织代码的各个方面, 它引入了称为 AspectJ 编译器 (ajc) 的编译器, 通过它编译我们的程序, 然后通过提供一个小型 (100K) 运行时库来运行它。</p>
<h4 id="3-4、Joinpoints"><a href="#3-4、Joinpoints" class="headerlink" title="3.4、Joinpoints"></a>3.4、Joinpoints</h4><p>在3.3 节中, 我们显示了 Spring AOP 是基于代理模式的。因此, 它需要将目标 Java 类分类, 并相应地应用交叉问题。</p>
<p>但这是有限制的。我们不能在 “最终” 类中应用交叉问题 (或方面), 因为它们不能被重写, 因此会导致运行时异常。</p>
<p>同样适用于静态和最终方法。不能将 Spring 方面应用于它们, 因为它们不能被覆盖。因此, 由于这些限制, Spring AOP 只支持方法执行连接点。</p>
<p>然而, AspectJ 在运行前直接将横切关注点编织到实际代码中。与 Spring AOP 不同, 它不需要对目标对象进行子类, 因此也支持许多其他 joinpoints。以下是支持的 joinpoints 的摘要:</p>
<table>
<thead>
<tr>
<th align="left">Joinpoint</th>
<th align="center">Spring AOP Supported</th>
<th align="center">AspectJ Supported</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Method Call</td>
<td align="center">No</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="left">Method Execution</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="left">Constructor Call</td>
<td align="center">No</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="left">Constructor Execution</td>
<td align="center">No</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="left">Static initializer execution</td>
<td align="center">No</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="left">Object initialization</td>
<td align="center">No</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="left">Field reference</td>
<td align="center">No</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="left">Field assignment</td>
<td align="center">No</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="left">Handler execution</td>
<td align="center">No</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="left">Advice execution</td>
<td align="center">No</td>
<td align="center">Yes</td>
</tr>
</tbody></table>
<p>还值得注意的是, 在 Spring AOP 中, aspects不应用于在同一个类中相互调用的方法。</p>
<p>这显然是因为当我们调用同一类中的方法时, 我们就不会调用 Spring AOP 提供的代理的方法。如果我们需要这个功能, 那么我们必须在不同的 bean 中定义一个单独的方法, 或者使用 AspectJ。</p>
<h4 id="3-5、简单性"><a href="#3-5、简单性" class="headerlink" title="3.5、简单性"></a>3.5、简单性</h4><p>Spring AOP 显然更简单, 因为它不会在我们的构建过程中引入任何额外的编译器或织入。它使用运行时编织, 因此它与我们通常的构建过程无缝集成。虽然它看起来很简单, 但它只适用于由 Spring 管理的 bean。</p>
<p>但是, 要使用 AspectJ, 我们需要引入 AspectJ 编译器 (ajc) 并重新打包所有的库 (除非我们切换到编译后或加载时间的织入)。</p>
<p>当然, 这比前者更复杂, 因为它引入了 AspectJ Java 工具 (包括编译器 (ajc)、调试器 (ajdb)、文档生成器 (ajdoc)、程序结构浏览器 (ajbrowser)), 我们需要将它们与我们的 IDE 或生成工具。</p>
<h4 id="3-6、性能"><a href="#3-6、性能" class="headerlink" title="3.6、性能"></a>3.6、性能</h4><p>就性能而言, 编译时织入比运行时织入快得多。Spring AOP 是基于代理的框架, 因此在应用程序启动时会创建代理。另外, 每个方面还有一些方法调用, 这会对性能产生负面影响。</p>
<p>另一方面, AspectJ 在应用程序执行之前将这些方面编织到主代码中, 因此没有额外的运行时开销, 与 Spring AOP 不同。</p>
<p>基于这些原因, 基准表明 AspectJ 的速度几乎比 Spring AOP 快8到35倍。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>此快速表总结了 Spring AOP 和 AspectJ 之间的关键区别:</p>
<table>
<thead>
<tr>
<th align="left">Spring AOP</th>
<th align="left">AspectJ</th>
</tr>
</thead>
<tbody><tr>
<td align="left">在纯 Java 中实现</td>
<td align="left">使用 Java 编程语言的扩展实现</td>
</tr>
<tr>
<td align="left">不需要单独的编译过程</td>
<td align="left">除非设置 LTW，否则需要 AspectJ 编译器 (ajc)</td>
</tr>
<tr>
<td align="left">只能使用运行时织入</td>
<td align="left">运行时织入不可用。支持编译时、编译后和加载时织入</td>
</tr>
<tr>
<td align="left">功能不强-仅支持方法级编织</td>
<td align="left">更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等……。</td>
</tr>
<tr>
<td align="left">只能在由 Spring 容器管理的 bean 上实现</td>
<td align="left">可以在所有域对象上实现</td>
</tr>
<tr>
<td align="left">仅支持方法执行切入点</td>
<td align="left">支持所有切入点</td>
</tr>
<tr>
<td align="left">代理是由目标对象创建的, 并且切面应用在这些代理上</td>
<td align="left">在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入</td>
</tr>
<tr>
<td align="left">比 AspectJ 慢多了</td>
<td align="left">更好的性能</td>
</tr>
<tr>
<td align="left">易于学习和应用</td>
<td align="left">相对于 Spring AOP 来说更复杂</td>
</tr>
</tbody></table>
<h2 id="5、选择正确的框架"><a href="#5、选择正确的框架" class="headerlink" title="5、选择正确的框架"></a>5、选择正确的框架</h2><p>如果我们分析了本节中提出的所有论点, 我们就会开始理解, 一个框架比另一个架构更好。<br> 简单地说, 选择很大程度上取决于我们的要求:</p>
<ul>
<li><strong>框架</strong>: 如果应用程序没有使用 spring 框架, 那么我们就别无选择, 只能放弃使用 spring AOP 的想法, 因为它无法管理任何超出 spring 容器范围的东西。但是, 如果我们的应用程序是完全使用 spring 框架创建的, 那么我们可以使用 spring AOP, 因为它是简单的学习和应用</li>
<li><strong>灵活性</strong>: 由于有限的 joinpoint 支持, Spring aop 不是一个完整的 aop 解决方案, 但它解决了程序员面临的最常见的问题。尽管如果我们想深入挖掘和开发 AOP 以达到其最大能力, 并希望得到广泛的可用 joinpoints 的支持, 那么最好选择 AspectJ</li>
<li><strong>性能</strong>: 如果我们使用的是有限的切面, 那么就会有细微的性能差异。但有时, 应用程序有成千上万个切面的情况。我们不想在这样的情况下使用运行时编织, 所以最好选择 AspectJ。AspectJ 已知的速度比 Spring AOP 快8到35倍</li>
<li><strong>两者的最佳之处</strong>: 这两个框架都是完全兼容的。我们总是可以利用 Spring AOP； 只要有可能, 仍然可以在不支持前者的地方使用 AspectJ 获得支持</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/spring/">spring</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/15/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">
                        <span class="hidden-mobile">动态代理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
