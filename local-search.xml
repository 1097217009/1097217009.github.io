<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring AOP</title>
    <link href="/2021/12/15/Spring%20AOP/"/>
    <url>/2021/12/15/Spring%20AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是AOP"><a href="#1-什么是AOP" class="headerlink" title="1.什么是AOP"></a>1.什么是AOP</h1><p>面向切面编程（AOP）和面向对象编程（OOP）类似，也是一种编程模式。Spring AOP基于AOP编程模式的一个框架，它的使用有效的减少了系统间的重复代码，达到了模块间的松耦合目的。</p><p>AOP的全程是“Aspect Oriented Programming”，即面向切面编程，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心核心业务，从而提高了开发效率。</p><p>AOP采取横向抽取机制，取代了传统纵向继承体系的重复代码，其应用主要体现在事务处理，日志管理，权限控制，异常处理等方面。</p><p>目前最流行的AOP框架有两个，分别为Spring AOP和AspectJ</p><p>Spring AOP使用纯java实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类织入增强的代码。</p><p>AspectJ是一个基于java语言的AOP框架，从Spring2.0开始，Spring AOP引入了对AspectJ的支持，AspectJ扩展了java语言，提供了一个专门的编译器，在编译时提供横向代码的织入。</p><h1 id="2-AOP的相关术语"><a href="#2-AOP的相关术语" class="headerlink" title="2.AOP的相关术语"></a>2.AOP的相关术语</h1><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Joinpoint(连接点)</td><td>指那些被拦截到的点，在Spring中，可以被动态代理拦截目标类的方法</td></tr><tr><td>Pointcut(切入点)</td><td>指要对哪些Joinpoint进行拦截，即被拦截的拦截点</td></tr><tr><td>Advice(通知)</td><td>指拦截到Joinpoint之后要做的事情，即对切入点增强的内容</td></tr><tr><td>Target(目标)</td><td>指代理的目标对象</td></tr><tr><td>Weaving(织入)</td><td>指把增强代码应用到目标上，生成代理对象的过程</td></tr><tr><td>Proxy(代理)</td><td>指生成的代理对象</td></tr><tr><td>Aspect(切面)</td><td>切入点和通知的结合</td></tr></tbody></table><p>Advice的类型（增强的时机）</p><table><thead><tr><th>术语</th><th>概念</th></tr></thead><tbody><tr><td>Before</td><td>在方法被调用之前执行增强</td></tr><tr><td>After</td><td>在方法被调用之后执行增强</td></tr><tr><td>After-running</td><td>在方法成功执行之后执行增强</td></tr><tr><td>After-throwing</td><td>在方法抛出指定异常后执行增强</td></tr><tr><td>Around</td><td>在方法调用的前后执行自定义的增强行为（最灵活的方式）</td></tr></tbody></table><h1 id="3-Spring-AOP的配置方式"><a href="#3-Spring-AOP的配置方式" class="headerlink" title="3.Spring AOP的配置方式"></a>3.Spring AOP的配置方式</h1><p>Spring AOP是基于动态代理的aop框架，这就意味着，要实现目标对象的各个方面，它将创建该对象的代理。使用以下两种方法之一实现：</p><p>1.JDK动态代理——-Spring AOP的首选方式。只要目标对象实现至少一个接口，就会使用JDK动态代理</p><p>2.CGLib代理——-如果目标对象没有实现接口，则可以使用CGLib代理。</p><p>Spring2.0之后，Spring AOP有了两种配置方式、</p><p>1.基于XML的方式</p><p>2.基于注解@Aspect的方式</p><h2 id="1-开启AOP功能"><a href="#1-开启AOP功能" class="headerlink" title="1.开启AOP功能"></a>1.开启AOP功能</h2><p>在XML中配置SpringAOP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了<br><br>&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-<span class="hljs-keyword">class</span>属性，默认为<span class="hljs-literal">false</span>，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;时，表示使用<span class="hljs-built_in">CGLib</span>动态代理技术织入增强。不过即使proxy-target-<span class="hljs-keyword">class</span>设置为<span class="hljs-literal">false</span>，如果目标类没有声明接口，则spring将自动使用<span class="hljs-built_in">CGLib</span>动态代理。<br></code></pre></td></tr></table></figure><p><strong>第二种方式</strong></p><p><strong>自定义类来实现Aop</strong></p><p>目标业务类不变依旧是userServiceImpl</p><p>第一步 : 写我们自己的一个切入类</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DiyPointcut &#123;<br><br>   <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">before</span>()&#123;<br>       <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;---------方法执行前---------&quot;);<br>  &#125;<br>   <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">after</span>()&#123;<br>       <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;---------方法执行后---------&quot;);<br>  &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>去spring中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="hljs-comment">&lt;!--注册bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.DiyPointcut&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--aop的配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;diy&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>       ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>       UserService userService = (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>       userService.add();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用@EnableAspectJAutoProxy注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Config</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>开启上述配置之后，在所有容器中，被AspectJ注解的bean都会被Spring当作是AOP配置类。成为一个Aspect。</p><p>@AspectJ注解只能作用于Spring Bean上面，所以要用@AspectJ修饰的类要么是用了@Component注解修饰，要么在XML中配置过。</p><p>例如如下的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-配置Pointcut-增强的切入点"><a href="#2-配置Pointcut-增强的切入点" class="headerlink" title="2.配置Pointcut(增强的切入点)"></a>2.配置Pointcut(增强的切入点)</h2><p>Pointcut在大部分地方被翻译成切点，用于定义哪些方法需要被增强或者说需要被拦截。</p><p>在Spring中，我们可以认为Pointcut是用来匹配Spring容器中所有满足指定条件的bean的方法</p><p>比如下面的写法：(Pointcut和Advice分开)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.service;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointcutConfig</span></span>&#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">poincut</span><span class="hljs-params">()</span></span>&#123;&#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p><code>*</code>代表任意返回值，<code>(..)</code>表示零个或多个任意参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span></span>&#123;<br>    <span class="hljs-meta">@Before(&quot;com.kuang.service.PointcutConfig.pointcut&quot;)</span>   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;do&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Pointcut和Advice结合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.config;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationPointcut</span> </span>&#123;<br>   <span class="hljs-meta">@Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行前---------&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行后---------&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint jp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;环绕前&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;签名:&quot;</span>+jp.getSignature());<br>       <span class="hljs-comment">//执行目标方法proceed</span><br>       Object proceed = jp.proceed();<br>       System.out.println(<span class="hljs-string">&quot;环绕后&quot;</span>);<br>       System.out.println(proceed);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/872d3dbdc2ca">https://www.jianshu.com/p/872d3dbdc2ca</a></p><h2 id="3、Spring-AOP-和-AspectJ"><a href="#3、Spring-AOP-和-AspectJ" class="headerlink" title="3、Spring AOP 和 AspectJ"></a>3、Spring AOP 和 AspectJ</h2><p>现在, 让我们在一些维度上讨论 Spring AOP 和 AspectJ —— 例如功能、目标、Weaving（织入）、内部结构、joinpoints 和简单性。</p><h4 id="3-1、能力和目标"><a href="#3-1、能力和目标" class="headerlink" title="3.1、能力和目标"></a>3.1、能力和目标</h4><p>简单地说, Spring AOP 和 AspectJ 有不同的目标。</p><p>Spring aop 旨在提供一个跨 Spring IoC 的简单的 aop 实现, 以解决程序员面临的最常见问题。<strong>它不打算作为一个完整的 AOP 解决方案</strong> —— 它只能应用于由 Spring 容器管理的 bean。</p><p>另一方面, AspectJ 是原始的 aop 技术, 目的是提供完整的 aop 解决方案。它更健壮, 但也比 Spring AOP 复杂得多。还值得注意的是, AspectJ 可以在所有域对象中应用。</p><h4 id="3-2、Weaving（织入）"><a href="#3-2、Weaving（织入）" class="headerlink" title="3.2、Weaving（织入）"></a>3.2、Weaving（织入）</h4><p>AspectJ 和 Spring AOP 都使用不同类型的编织, 这会影响它们在性能和易用性方面的行为。</p><p>AspectJ 使用三种不同类型的Weaving:</p><ol><li><strong>编译时 Weaving</strong>: AspectJ 编译器作为输入我们的方面的源代码和我们的应用, 并产生一个织入类文件作为输出；</li><li><strong>编译后 Weaving</strong>: 这也称为二进制织入。它是用来织入现有的类文件和 JAR 文件与我们的方面；</li><li><strong>加载时间 Weaving</strong>: 这就像前二进制织入, 不同的是织入被推迟, 直到类加载程序加载类文件到 JVM。</li></ol><p>要了解更多关于 AspectJ 本身的详细信息, 请 <a href="https://link.jianshu.com/?t=http://www.baeldung.com/aspectj">阅读此文</a>。</p><p>当 AspectJ 使用编译时和class文件加载时织入时，Spring AOP 利用运行时织入。</p><p>使用运行时编织, 这些方面在使用目标对象的代理执行应用程序时被编织-使用 JDK 动态代理或 CGLIB 代理 (在下一点讨论):</p><p><img src="https://upload-images.jianshu.io/upload_images/7179784-5d499156cfbeba32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image</p><h4 id="3-3、内部结构与应用"><a href="#3-3、内部结构与应用" class="headerlink" title="3.3、内部结构与应用"></a>3.3、内部结构与应用</h4><p>Spring aop 是基于代理的 aop 框架。这意味着, 要实现目标对象的各个方面, 它将创建该对象的代理。使用以下两种方法之一实现:</p><ol><li>JDK 动态代理 —— Spring AOP 的首选方式。只要目标对象实现甚至一个接口, 就会使用 JDK 动态代理；</li><li>CGLIB 代理 —— 如果目标对象没有实现接口, 则可以使用 CGLIB 代理。</li></ol><p>我们可以从 <a href="https://link.jianshu.com/?t=https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html%23aop-proxying">官方文档</a> 中了解有关 Spring AOP 代理机制的更多信息。</p><p>另一方面, AspectJ 在运行时不做任何事情, 因为类是直接用方面进行编译的。</p><p>与 Spring AOP 不同, 它不需要任何设计模式。为了编织代码的各个方面, 它引入了称为 AspectJ 编译器 (ajc) 的编译器, 通过它编译我们的程序, 然后通过提供一个小型 (100K) 运行时库来运行它。</p><h4 id="3-4、Joinpoints"><a href="#3-4、Joinpoints" class="headerlink" title="3.4、Joinpoints"></a>3.4、Joinpoints</h4><p>在3.3 节中, 我们显示了 Spring AOP 是基于代理模式的。因此, 它需要将目标 Java 类分类, 并相应地应用交叉问题。</p><p>但这是有限制的。我们不能在 “最终” 类中应用交叉问题 (或方面), 因为它们不能被重写, 因此会导致运行时异常。</p><p>同样适用于静态和最终方法。不能将 Spring 方面应用于它们, 因为它们不能被覆盖。因此, 由于这些限制, Spring AOP 只支持方法执行连接点。</p><p>然而, AspectJ 在运行前直接将横切关注点编织到实际代码中。与 Spring AOP 不同, 它不需要对目标对象进行子类, 因此也支持许多其他 joinpoints。以下是支持的 joinpoints 的摘要:</p><table><thead><tr><th align="left">Joinpoint</th><th align="center">Spring AOP Supported</th><th align="center">AspectJ Supported</th></tr></thead><tbody><tr><td align="left">Method Call</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="left">Method Execution</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="left">Constructor Call</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="left">Constructor Execution</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="left">Static initializer execution</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="left">Object initialization</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="left">Field reference</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="left">Field assignment</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="left">Handler execution</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="left">Advice execution</td><td align="center">No</td><td align="center">Yes</td></tr></tbody></table><p>还值得注意的是, 在 Spring AOP 中, aspects不应用于在同一个类中相互调用的方法。</p><p>这显然是因为当我们调用同一类中的方法时, 我们就不会调用 Spring AOP 提供的代理的方法。如果我们需要这个功能, 那么我们必须在不同的 bean 中定义一个单独的方法, 或者使用 AspectJ。</p><h4 id="3-5、简单性"><a href="#3-5、简单性" class="headerlink" title="3.5、简单性"></a>3.5、简单性</h4><p>Spring AOP 显然更简单, 因为它不会在我们的构建过程中引入任何额外的编译器或织入。它使用运行时编织, 因此它与我们通常的构建过程无缝集成。虽然它看起来很简单, 但它只适用于由 Spring 管理的 bean。</p><p>但是, 要使用 AspectJ, 我们需要引入 AspectJ 编译器 (ajc) 并重新打包所有的库 (除非我们切换到编译后或加载时间的织入)。</p><p>当然, 这比前者更复杂, 因为它引入了 AspectJ Java 工具 (包括编译器 (ajc)、调试器 (ajdb)、文档生成器 (ajdoc)、程序结构浏览器 (ajbrowser)), 我们需要将它们与我们的 IDE 或生成工具。</p><h4 id="3-6、性能"><a href="#3-6、性能" class="headerlink" title="3.6、性能"></a>3.6、性能</h4><p>就性能而言, 编译时织入比运行时织入快得多。Spring AOP 是基于代理的框架, 因此在应用程序启动时会创建代理。另外, 每个方面还有一些方法调用, 这会对性能产生负面影响。</p><p>另一方面, AspectJ 在应用程序执行之前将这些方面编织到主代码中, 因此没有额外的运行时开销, 与 Spring AOP 不同。</p><p>基于这些原因, 基准表明 AspectJ 的速度几乎比 Spring AOP 快8到35倍。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>此快速表总结了 Spring AOP 和 AspectJ 之间的关键区别:</p><table><thead><tr><th align="left">Spring AOP</th><th align="left">AspectJ</th></tr></thead><tbody><tr><td align="left">在纯 Java 中实现</td><td align="left">使用 Java 编程语言的扩展实现</td></tr><tr><td align="left">不需要单独的编译过程</td><td align="left">除非设置 LTW，否则需要 AspectJ 编译器 (ajc)</td></tr><tr><td align="left">只能使用运行时织入</td><td align="left">运行时织入不可用。支持编译时、编译后和加载时织入</td></tr><tr><td align="left">功能不强-仅支持方法级编织</td><td align="left">更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等……。</td></tr><tr><td align="left">只能在由 Spring 容器管理的 bean 上实现</td><td align="left">可以在所有域对象上实现</td></tr><tr><td align="left">仅支持方法执行切入点</td><td align="left">支持所有切入点</td></tr><tr><td align="left">代理是由目标对象创建的, 并且切面应用在这些代理上</td><td align="left">在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入</td></tr><tr><td align="left">比 AspectJ 慢多了</td><td align="left">更好的性能</td></tr><tr><td align="left">易于学习和应用</td><td align="left">相对于 Spring AOP 来说更复杂</td></tr></tbody></table><h2 id="5、选择正确的框架"><a href="#5、选择正确的框架" class="headerlink" title="5、选择正确的框架"></a>5、选择正确的框架</h2><p>如果我们分析了本节中提出的所有论点, 我们就会开始理解, 一个框架比另一个架构更好。<br> 简单地说, 选择很大程度上取决于我们的要求:</p><ul><li><strong>框架</strong>: 如果应用程序没有使用 spring 框架, 那么我们就别无选择, 只能放弃使用 spring AOP 的想法, 因为它无法管理任何超出 spring 容器范围的东西。但是, 如果我们的应用程序是完全使用 spring 框架创建的, 那么我们可以使用 spring AOP, 因为它是简单的学习和应用</li><li><strong>灵活性</strong>: 由于有限的 joinpoint 支持, Spring aop 不是一个完整的 aop 解决方案, 但它解决了程序员面临的最常见的问题。尽管如果我们想深入挖掘和开发 AOP 以达到其最大能力, 并希望得到广泛的可用 joinpoints 的支持, 那么最好选择 AspectJ</li><li><strong>性能</strong>: 如果我们使用的是有限的切面, 那么就会有细微的性能差异。但有时, 应用程序有成千上万个切面的情况。我们不想在这样的情况下使用运行时编织, 所以最好选择 AspectJ。AspectJ 已知的速度比 Spring AOP 快8到35倍</li><li><strong>两者的最佳之处</strong>: 这两个框架都是完全兼容的。我们总是可以利用 Spring AOP； 只要有可能, 仍然可以在不支持前者的地方使用 AspectJ 获得支持</li></ul>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态代理</title>
    <link href="/2021/12/15/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2021/12/15/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1.代理模式"></a>1.代理模式</h1><p>代理模式是指，为其他对象提供一种代理可以控制这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。另外一个意思是，使用代理对象，是为了在不修改目标对象的基础上，==增强主业务逻辑==。客户类真正想访问的对象是目标对象，但客户类真正可以访问的对象是代理对象。客户类对目标对象的访问是通过访问代理对象来实现的。当然，代理类与目标类要实现同一个接口（JDK动态代理）。</p><p>例如：结婚需要找中介帮忙布置场所什么的。</p><p>使用代理模式的作用：</p><p>==1.功能增强==</p><p>2.控制访问</p><h1 id="2-实现代理的方式"><a href="#2-实现代理的方式" class="headerlink" title="2.实现代理的方式"></a>2.实现代理的方式</h1><h2 id="1-静态代理："><a href="#1-静态代理：" class="headerlink" title="1.静态代理："></a>1.静态代理：</h2><p>代理类是自己手工实现的，自己创建一个java类，表示代理类，同时你所要代理的目标类是确定的</p><p>特点：1）实现简单 2）容易理解</p><p>例子：模拟一个用户购买u盘的行为</p><p>​    用户是客户类</p><p>​    商家是代理对象，代理某个品牌的值</p><p>​    厂家是目标类</p><p>实现步骤：</p><p>​    1.创建一个接口，定义卖u盘的方法，表示厂家和商家做的事情</p><p>​    2.创建厂家类，实现步骤1的接口</p><p>​    3.创建商家，也就是代理，也需要实现步骤1的接口</p><p>​    3.创建客户类，调用商家的方法买一个u盘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UsbSale</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//厂家</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsbFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsbSale</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;生产了U盘&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//商家(代理)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsbProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsbSale</span></span>&#123;<br>    <span class="hljs-keyword">private</span> UsbFactory usbFactory;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span></span>&#123;<br>        usbFactory.sale();<br>        System.out.println(<span class="hljs-string">&quot;卖出了商家生产的U盘&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        UsbProxy usbProxy;<br>        usbProxy.sale();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态代理的缺点：</p><p>1.当目标类增多了，代理也会相应的增多。</p><p>2.当接口中方法新增或减少时，代理对象也要相应改变。</p><h2 id="2-动态代理："><a href="#2-动态代理：" class="headerlink" title="2.动态代理："></a>2.动态代理：</h2><p>在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点</p><p>动态代理中目标类即使很多，1）代理类数量可以很少    2）当你修改了接口中的方法时，不会影响代理类</p><h3 id="1-JDK动态代理："><a href="#1-JDK动态代理：" class="headerlink" title="1.JDK动态代理："></a>1.JDK动态代理：</h3><p>在程序的执行过程中，使用jdk的反射机制，创建代理类对象，并且动态的指定要代理的目标类。换句话说：动态代理是一种创建java对象的能力，让我们可以在运行过程中动态创建代理对象。</p><p>一般情况下，在java中想要创建对象：</p><p>1.创建类文件，java文件编译为class</p><p>2.使用构造方法，创建类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//目标对象实现的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//目标对象1</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTarget1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;do&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//目标对象2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTarget2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;do other things&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK动态代理,这个类MyProxyInvocationHandler实现InvocationHandler接口，通过其中getProxy()得到的代理对象会有构造方法带有参数MyProxyInvocationHandler，代理对象在调用目标接口的方法时会通过调用MyProxyInvocationHandler对象中的invoke(Object o, Method method, Object[] objects)方式。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProxyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;<br>    <span class="hljs-comment">//要代理的目标类，类型为Object类，也就是说可以为任何类型的类创建代理，但是这个类一定要实现某个接口，因为JDK代理的是接口</span><br>    <span class="hljs-keyword">private</span> Object object;<br>    <span class="hljs-comment">//set方法实现注入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObject</span><span class="hljs-params">(Object object)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.object = object;<br>    &#125;<br>    <br>    <span class="hljs-comment">//动态创建代理类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterface,<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//实现增强的地方</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object o, Method method, Object[] objects)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object obj = method.invoke(object,objects);<br>        System.out.println(<span class="hljs-string">&quot;实现增强&quot;</span>);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>jdk动态代理原理分析</p><p>主要分析的地方是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterface,<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p>进去源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          InvocationHandler h)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IllegalArgumentException</span><br><span class="hljs-function">    </span>&#123;<br>        Objects.requireNonNull(h);<br><br>        <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();<br>        <span class="hljs-keyword">final</span> SecurityManager sm = System.getSecurityManager();<br>        <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;<br>            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Look up or generate the designated proxy class.</span><br><span class="hljs-comment">         */</span><br>        Class&lt;?&gt; cl = getProxyClass0(loader, intfs); <span class="hljs-comment">//再进入getProxyClass0()方法的源码</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Invoke its constructor with the designated invocation handler.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;<br>                checkNewProxyPermission(Reflection.getCallerClass(), cl);<br>            &#125;<br><br>            <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br>            <span class="hljs-keyword">final</span> InvocationHandler ih = h;<br>            <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;<br>                AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        cons.setAccessible(<span class="hljs-keyword">true</span>);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                &#125;);<br>            &#125;<br>            <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> Object[]&#123;h&#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e.toString(), e);<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>            Throwable t = e.getCause();<br>            <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;<br>                <span class="hljs-keyword">throw</span> (RuntimeException) t;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(t.toString(), t);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e.toString(), e);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p> Class&lt;?&gt; cl = getProxyClass0(loader, intfs);的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,<br>                                       Class&lt;?&gt;... interfaces) &#123;<br>    <span class="hljs-keyword">if</span> (interfaces.length &gt; <span class="hljs-number">65535</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;interface limit exceeded&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// If the proxy class defined by the given loader implementing</span><br>    <span class="hljs-comment">// the given interfaces exists, this will simply return the cached copy;</span><br>    <span class="hljs-comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span><br>    <span class="hljs-keyword">return</span> proxyClassCache.get(loader, interfaces);<br>&#125;<br></code></pre></td></tr></table></figure><p>proxyClassCache.get(loader, interfaces)</p><p>proxyClassCache是WeakCache对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;<br>    proxyClassCache = <span class="hljs-keyword">new</span> WeakCache&lt;&gt;(<span class="hljs-keyword">new</span> KeyFactory(), <span class="hljs-keyword">new</span> ProxyClassFactory());<br></code></pre></td></tr></table></figure><p>进入到WeakCache类的get()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key, P parameter)</span> </span>&#123;<br>        Objects.requireNonNull(parameter);<br><br>        expungeStaleEntries();<br><br>        Object cacheKey = CacheKey.valueOf(key, refQueue);<br><br>        <span class="hljs-comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span><br>        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);<br>        <span class="hljs-keyword">if</span> (valuesMap == <span class="hljs-keyword">null</span>) &#123;<br>            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap<br>                = map.putIfAbsent(cacheKey,<br>                                  valuesMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;());<br>            <span class="hljs-keyword">if</span> (oldValuesMap != <span class="hljs-keyword">null</span>) &#123;<br>                valuesMap = oldValuesMap;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span><br>        <span class="hljs-comment">// subKey from valuesMap</span><br>        Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));<br>        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);<br>        Factory factory = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (supplier != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span><br>                V value = supplier.get();<br>                <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> value;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// else no supplier in cache</span><br>            <span class="hljs-comment">// or a supplier that returned null (could be a cleared CacheValue</span><br>            <span class="hljs-comment">// or a Factory that wasn&#x27;t successful in installing the CacheValue)</span><br><br>            <span class="hljs-comment">// lazily construct a Factory</span><br>            <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) &#123;<br>                factory = <span class="hljs-keyword">new</span> Factory(key, parameter, subKey, valuesMap);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (supplier == <span class="hljs-keyword">null</span>) &#123;<br>                supplier = valuesMap.putIfAbsent(subKey, factory);<br>                <span class="hljs-keyword">if</span> (supplier == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// successfully installed Factory</span><br>                    supplier = factory;<br>                &#125;<br>                <span class="hljs-comment">// else retry with winning supplier</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;<br>                    <span class="hljs-comment">// successfully replaced</span><br>                    <span class="hljs-comment">// cleared CacheEntry / unsuccessful Factory</span><br>                    <span class="hljs-comment">// with our Factory</span><br>                    supplier = factory;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// retry with current supplier</span><br>                    supplier = valuesMap.get(subKey);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>Supplier<V> supplier = valuesMap.get(subKey);</p><p>get方法返回值为： supplier.get()</p><p>进入WeakCache内部类Factory的get()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> K key;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> P parameter;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object subKey;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap;<br><br>        Factory(K key, P parameter, Object subKey,<br>                ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.parameter = parameter;<br>            <span class="hljs-keyword">this</span>.subKey = subKey;<br>            <span class="hljs-keyword">this</span>.valuesMap = valuesMap;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// serialize access</span><br>            <span class="hljs-comment">// re-check</span><br>            Supplier&lt;V&gt; supplier = valuesMap.get(subKey);<br>            <span class="hljs-keyword">if</span> (supplier != <span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-comment">// something changed while we were waiting:</span><br>                <span class="hljs-comment">// might be that we were replaced by a CacheValue</span><br>                <span class="hljs-comment">// or were removed because of failure -&gt;</span><br>                <span class="hljs-comment">// return null to signal WeakCache.get() to retry</span><br>                <span class="hljs-comment">// the loop</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-comment">// else still us (supplier == this)</span><br><br>            <span class="hljs-comment">// create new value</span><br>            V value = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                value = Objects.requireNonNull(valueFactory.apply(key, parameter));<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// remove us on failure</span><br>                    valuesMap.remove(subKey, <span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// the only path to reach here is with non-null value</span><br>            <span class="hljs-keyword">assert</span> value != <span class="hljs-keyword">null</span>;<br><br>            <span class="hljs-comment">// wrap value with CacheValue (WeakReference)</span><br>            CacheValue&lt;V&gt; cacheValue = <span class="hljs-keyword">new</span> CacheValue&lt;&gt;(value);<br><br>            <span class="hljs-comment">// put into reverseMap</span><br>            reverseMap.put(cacheValue, Boolean.TRUE);<br><br>            <span class="hljs-comment">// try replacing us with CacheValue (this should always succeed)</span><br>            <span class="hljs-keyword">if</span> (!valuesMap.replace(subKey, <span class="hljs-keyword">this</span>, cacheValue)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">&quot;Should not reach here&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">// successfully replaced us with new CacheValue -&gt; return the value</span><br>            <span class="hljs-comment">// wrapped by it</span><br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>返回值value= Objects.requireNonNull(valueFactory.apply(key, parameter));</p><p>进入valueFactory.apply(key, parameter)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyClassFactory</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">BiFunction</span>&lt;<span class="hljs-title">ClassLoader</span>, <span class="hljs-title">Class</span>&lt;?&gt;[], <span class="hljs-title">Class</span>&lt;?&gt;&gt;</span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">// prefix for all proxy class names</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String proxyClassNamePrefix = <span class="hljs-string">&quot;$Proxy&quot;</span>;<br><br>    <span class="hljs-comment">// next number to use for generation of unique proxy class names</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicLong nextUniqueNumber = <span class="hljs-keyword">new</span> AtomicLong();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;<br><br>        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="hljs-keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Verify that the class loader resolves the name of this</span><br><span class="hljs-comment">             * interface to the same Class object.</span><br><span class="hljs-comment">             */</span><br>            Class&lt;?&gt; interfaceClass = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                interfaceClass = Class.forName(intf.getName(), <span class="hljs-keyword">false</span>, loader);<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (interfaceClass != intf) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    intf + <span class="hljs-string">&quot; is not visible from class loader&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Verify that the Class object actually represents an</span><br><span class="hljs-comment">             * interface.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (!interfaceClass.isInterface()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    interfaceClass.getName() + <span class="hljs-string">&quot; is not an interface&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Verify that this interface is not a duplicate.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    <span class="hljs-string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());<br>            &#125;<br>        &#125;<br><br>        String proxyPkg = <span class="hljs-keyword">null</span>;     <span class="hljs-comment">// package to define proxy class in</span><br>        <span class="hljs-keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Record the package of a non-public proxy interface so that the</span><br><span class="hljs-comment">         * proxy class will be defined in the same package.  Verify that</span><br><span class="hljs-comment">         * all non-public proxy interfaces are in the same package.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;<br>            <span class="hljs-keyword">int</span> flags = intf.getModifiers();<br>            <span class="hljs-keyword">if</span> (!Modifier.isPublic(flags)) &#123;<br>                accessFlags = Modifier.FINAL;<br>                String name = intf.getName();<br>                <span class="hljs-keyword">int</span> n = name.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                String pkg = ((n == -<span class="hljs-number">1</span>) ? <span class="hljs-string">&quot;&quot;</span> : name.substring(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">if</span> (proxyPkg == <span class="hljs-keyword">null</span>) &#123;<br>                    proxyPkg = pkg;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!pkg.equals(proxyPkg)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                        <span class="hljs-string">&quot;non-public interfaces from different packages&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (proxyPkg == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// if no non-public proxy interfaces, use com.sun.proxy package</span><br>            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="hljs-string">&quot;.&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Choose a name for the proxy class to generate.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">long</span> num = nextUniqueNumber.getAndIncrement();<br>        String proxyName = proxyPkg + proxyClassNamePrefix + num;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Generate the specified proxy class.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(<br>            proxyName, interfaces, accessFlags);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> defineClass0(loader, proxyName,<br>                                proxyClassFile, <span class="hljs-number">0</span>, proxyClassFile.length);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassFormatError e) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * A ClassFormatError here means that (barring bugs in the</span><br><span class="hljs-comment">             * proxy class generation code) there was some other</span><br><span class="hljs-comment">             * invalid aspect of the arguments supplied to the proxy</span><br><span class="hljs-comment">             * class creation (such as virtual machine limitations</span><br><span class="hljs-comment">             * exceeded).</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(e.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现重点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(<br>    proxyName, interfaces, accessFlags);<br></code></pre></td></tr></table></figure><p>这里生成了代理类的字节码文件</p><p>通过反编译可以很清楚的看到代理类暂且叫做MyProxy继承了Proxy类并且实现了参数里的所有接口，另外MyProxy有一个构造方法：</p><p>public MyProxy(InvocationHandler paramInvocationHandler){</p><p>​    super(paramInvocationHandler);</p><p>}</p><p>MyProxy的父类Proxy类中的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Proxy</span><span class="hljs-params">(InvocationHandler h)</span> </span>&#123;<br>    Objects.requireNonNull(h);<br>    <span class="hljs-keyword">this</span>.h = h;<br>&#125;<br></code></pre></td></tr></table></figure><p>MyProxy类结构大概如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.UndeclaredThrowableException;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProxy</span></span><br><span class="hljs-class">  <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span></span><br><span class="hljs-class">  <span class="hljs-keyword">implements</span> 接口</span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m4;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyProxy</span><span class="hljs-params">(InvocationHandler paramInvocationHandler)</span></span><br><span class="hljs-function">  </span>&#123;<br>     <span class="hljs-keyword">super</span>(paramInvocationHandler);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object paramObject)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> ((Boolean)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[] &#123; paramObject &#125;)).booleanValue();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Error|RuntimeException localError)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> localError;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable localThrowable)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(localThrowable);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">SayGoodBye</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Error|RuntimeException localError)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> localError;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable localThrowable)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(localThrowable);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">SayHello</span><span class="hljs-params">(String paramString)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m4, <span class="hljs-keyword">new</span> Object[] &#123; paramString &#125;);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Error|RuntimeException localError)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> localError;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable localThrowable)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(localThrowable);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Error|RuntimeException localError)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> localError;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable localThrowable)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(localThrowable);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> ((Integer)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, <span class="hljs-keyword">null</span>)).intValue();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Error|RuntimeException localError)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> localError;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable localThrowable)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(localThrowable);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">static</span><br>  &#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, <span class="hljs-keyword">new</span> Class[] &#123; Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>) &#125;);<br>      m3 = Class.forName(<span class="hljs-string">&quot;jiankunking.Subject&quot;</span>).getMethod(<span class="hljs-string">&quot;SayGoodBye&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>      m4 = Class.forName(<span class="hljs-string">&quot;jiankunking.Subject&quot;</span>).getMethod(<span class="hljs-string">&quot;SayHello&quot;</span>, <span class="hljs-keyword">new</span> Class[] &#123; Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>) &#125;);<br>      m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>      m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ClassNotFoundException localClassNotFoundException)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-CGLib动态代理："><a href="#2-CGLib动态代理：" class="headerlink" title="2.CGLib动态代理："></a>2.CGLib动态代理：</h3><p>CGLIB是一个基于ASM框架的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承的方式实现代理，在子类中采用拦截的技术拦截所有父类的调用并顺势织入横切逻辑。</p><p>CGLib例子：</p><p>写一个目标类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;juest do it&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写一个类并且实现接口 net.sf.cglib.proxy.MethodInterceptor</p><p>首先看看接口net.sf.cglib.proxy.MethodInterceptor的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span> </span>&#123;<br>    <span class="hljs-function">Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object var1, Method var2, Object[] var3, MethodProxy var4)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看看他的父类Callback的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callback</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们现在自定义一个类MyMethodInterceptor并实现MethodInterceptor接口的intercept方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy methodProxy)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before just do it&quot;</span>);<br>        Object object = methodProxy.invokeSuper(obj,args);<span class="hljs-comment">//just do it</span><br>        SYstem.out.println(<span class="hljs-string">&quot;after just do it&quot;</span>);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        enhancer.setSuperclass(Target.class);<br>        enhancer.setCallback(<span class="hljs-keyword">new</span> MyMethodInterceptor());<br>        Target targetProxy = (Target)enhancer.create();<br>        target.dosomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据使用CGLib创建动态代理对象过程分析源码：</p><p>可以看到先是实例化了一个Enhancer(所在的包net.sf.cglib.proxy.Enhancer)对象 enhancer</p><p>接着调用的两个set方法：</p><p>setSuperclass(目标类的Class对象)和setCallback(实现了MethodInterceptor接口的对象)</p><p>它们的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class superclass;   <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSuperclass</span><span class="hljs-params">(Class superclass)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (superclass != <span class="hljs-keyword">null</span> &amp;&amp; superclass.isInterface()) &#123;<br>           <span class="hljs-keyword">this</span>.setInterfaces(<span class="hljs-keyword">new</span> Class[]&#123;superclass&#125;);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (superclass != <span class="hljs-keyword">null</span> &amp;&amp; superclass.equals(Object.class)) &#123;<br>           <span class="hljs-keyword">this</span>.superclass = <span class="hljs-keyword">null</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">this</span>.superclass = superclass;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Callback[] callbacks;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallback</span><span class="hljs-params">(Callback callback)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.setCallbacks(<span class="hljs-keyword">new</span> Callback[]&#123;callback&#125;);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallbacks</span><span class="hljs-params">(Callback[] callbacks)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (callbacks != <span class="hljs-keyword">null</span> &amp;&amp; callbacks.length == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Array cannot be empty&quot;</span>);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">this</span>.callbacks = callbacks;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>重点地方是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Target targetProxy = (Target)enhancer.create();<br></code></pre></td></tr></table></figure><p>进入creat()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.classOnly = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">this</span>.argumentTypes = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.createHelper();<br>&#125;<br></code></pre></td></tr></table></figure><p>没有重点再进入createHelper()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">createHelper</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.preValidate();<br>    Object key = KEY_FACTORY.newInstance(<span class="hljs-keyword">this</span>.superclass != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.superclass.getName() : <span class="hljs-keyword">null</span>, ReflectUtils.getNames(<span class="hljs-keyword">this</span>.interfaces), <span class="hljs-keyword">this</span>.filter == ALL_ZERO ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> WeakCacheKey(<span class="hljs-keyword">this</span>.filter), <span class="hljs-keyword">this</span>.callbackTypes, <span class="hljs-keyword">this</span>.useFactory, <span class="hljs-keyword">this</span>.interceptDuringConstruction, <span class="hljs-keyword">this</span>.serialVersionUID);<br>    <span class="hljs-keyword">this</span>.currentKey = key;<br>    Object result = <span class="hljs-keyword">super</span>.create(key);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到返回值result=super.create(key)；</p><p>进入再看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ClassLoader loader = <span class="hljs-keyword">this</span>.getClassLoader();<br>            Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; cache = CACHE;<br>            AbstractClassGenerator.ClassLoaderData data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);<br>            <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>) &#123;<br>                Class var5 = AbstractClassGenerator.class;<br>                <span class="hljs-keyword">synchronized</span>(AbstractClassGenerator.class) &#123;<br>                    cache = CACHE;<br>                    data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);<br>                    <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>) &#123;<br>                        Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; newCache = <span class="hljs-keyword">new</span> WeakHashMap(cache);<br>                        data = <span class="hljs-keyword">new</span> AbstractClassGenerator.ClassLoaderData(loader);<br>                        newCache.put(loader, data);<br>                        CACHE = newCache;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">this</span>.key = key;<br>            Object obj = data.get(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.getUseCache());<br>            <span class="hljs-keyword">return</span> obj <span class="hljs-keyword">instanceof</span> Class ? <span class="hljs-keyword">this</span>.firstInstance((Class)obj) : <span class="hljs-keyword">this</span>.nextInstance(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException var9) &#123;<br>            <span class="hljs-keyword">throw</span> var9;<br>        &#125; <span class="hljs-keyword">catch</span> (Error var10) &#123;<br>            <span class="hljs-keyword">throw</span> var10;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var11) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CodeGenerationException(var11);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>追踪</p><p>Object obj = data.get(this, this.getUseCache());</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(AbstractClassGenerator gen, <span class="hljs-keyword">boolean</span> useCache)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!useCache) &#123;<br>        <span class="hljs-keyword">return</span> gen.generate(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//追踪进去</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Object cachedValue = <span class="hljs-keyword">this</span>.generatedClasses.get(gen);<br>        <span class="hljs-keyword">return</span> gen.unwrapCachedValue(cachedValue);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Class <span class="hljs-title">generate</span><span class="hljs-params">(AbstractClassGenerator.ClassLoaderData data)</span> </span>&#123;<br>        Object save = CURRENT.get();<br>        CURRENT.set(<span class="hljs-keyword">this</span>);<br><br>        Class var8;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ClassLoader classLoader = data.getClassLoader();<br>            <span class="hljs-keyword">if</span> (classLoader == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;ClassLoader is null while trying to define class &quot;</span> + <span class="hljs-keyword">this</span>.getClassName() + <span class="hljs-string">&quot;. It seems that the loader has been expired from a weak reference somehow. Please file an issue at cglib&#x27;s issue tracker.&quot;</span>);<br>            &#125;<br><br>            String className;<br>            <span class="hljs-keyword">synchronized</span>(classLoader) &#123;<br>                className = <span class="hljs-keyword">this</span>.generateClassName(data.getUniqueNamePredicate());<br>                data.reserveName(className);<br>                <span class="hljs-keyword">this</span>.setClassName(className);<br>            &#125;<br><br>            Class gen;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.attemptLoad) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    gen = classLoader.loadClass(<span class="hljs-keyword">this</span>.getClassName());<br>                    Class var25 = gen;<br>                    <span class="hljs-keyword">return</span> var25;<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var20) &#123;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">this</span>.strategy.generate(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//新大陆，字节码文件</span><br>            className = ClassNameReader.getClassName(<span class="hljs-keyword">new</span> ClassReader(b));<br>            ProtectionDomain protectionDomain = <span class="hljs-keyword">this</span>.getProtectionDomain();<br>            <span class="hljs-comment">//根据字节码生成代理类对象</span><br>            <span class="hljs-keyword">synchronized</span>(classLoader) &#123;<br>                <span class="hljs-keyword">if</span> (protectionDomain == <span class="hljs-keyword">null</span>) &#123;<br>                    gen = ReflectUtils.defineClass(className, b, classLoader);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);<br>                &#125;<br>            &#125;<br><br>            var8 = gen;<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException var21) &#123;<br>            <span class="hljs-keyword">throw</span> var21;<br>        &#125; <span class="hljs-keyword">catch</span> (Error var22) &#123;<br>            <span class="hljs-keyword">throw</span> var22;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var23) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CodeGenerationException(var23);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            CURRENT.set(save);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> var8;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到返回值是return obj instanceof Class ? this.firstInstance((Class)obj) : this.nextInstance(obj);</p><p>进入到Enhancer类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">nextInstance</span><span class="hljs-params">(Object instance)</span> </span>&#123;<br>    Enhancer.EnhancerFactoryData data = (Enhancer.EnhancerFactoryData)instance;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.classOnly) &#123;<br>        <span class="hljs-keyword">return</span> data.generatedClass;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Class[] argumentTypes = <span class="hljs-keyword">this</span>.argumentTypes;<br>        Object[] arguments = <span class="hljs-keyword">this</span>.arguments;<br>        <span class="hljs-keyword">if</span> (argumentTypes == <span class="hljs-keyword">null</span>) &#123;<br>            argumentTypes = Constants.EMPTY_CLASS_ARRAY;<br>            arguments = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> data.newInstance(argumentTypes, arguments, <span class="hljs-keyword">this</span>.callbacks);<span class="hljs-comment">//反射创建对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过字节码反编译出来大概如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span>$$<span class="hljs-title">EnhancerByCGLIB</span>$$<span class="hljs-title">c7ae5d4e</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method CGLIB$doSomething$<span class="hljs-number">0</span>$Method;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MethodProxy CGLIB$doSomething$<span class="hljs-number">0</span>$Proxy;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> CGLIB$STATICHOOK1() &#123;<br>        Class var0 = Class.forName(<span class="hljs-string">&quot;com.codezhao.designpattern.proxypattern.cglibproxy.Person$$EnhancerByCGLIB$$c7ae5d4e&quot;</span>);<br>        Class var1;<br>        CGLIB$run$<span class="hljs-number">0</span>$Method = ReflectUtils.findMethods(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>&#125;, (var1 = Class.forName(<span class="hljs-string">&quot;com.codezhao.designpattern.proxypattern.cglibproxy.Target&quot;</span>)).getDeclaredMethods())[<span class="hljs-number">0</span>];<br>        CGLIB$run$<span class="hljs-number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-string">&quot;doSomething&quot;</span>, <span class="hljs-string">&quot;CGLIB$doSomething$0&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> CGLIB$doSomething$<span class="hljs-number">0</span>() &#123;<br>        <span class="hljs-keyword">super</span>.doSomething();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        MethodInterceptor var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;<br>        <span class="hljs-keyword">if</span> (var10000 == <span class="hljs-keyword">null</span>) &#123;<br>            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);<br>            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (var10000 != <span class="hljs-keyword">null</span>) &#123;<br>            var10000.intercept(<span class="hljs-keyword">this</span>, CGLIB$doSomething$<span class="hljs-number">0</span>$Method, CGLIB$emptyArgs, CGLIB$doSomething$<span class="hljs-number">0</span>$Proxy);<span class="hljs-comment">//执行自定义拦截器</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">super</span>.doSomething();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理类<code>doSomething()</code>方法中，会调用方法拦截器的<code>intercept()</code>方法，方法拦截器会通过某些手段找到代理类的<code>CGLIB$doSomething$0()</code>方法，最后实现调用父类即被代理类Target的doSomething()方法，这个手段在Jdk中是反射，而在Cglib中是一种新的机制-FastClass机制。</p><h3 id="总结：两种动态代理方式的特点"><a href="#总结：两种动态代理方式的特点" class="headerlink" title="总结：两种动态代理方式的特点"></a>总结：两种动态代理方式的特点</h3><p>JDK动态代理：</p><p>1.通过实现InvocationHandler接口创建自己的调用处理器</p><p>2.通过为Porxy类指定ClassLoader对象和一组interface来创建动态代理</p><p>3.通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型</p><p>3.通过构造函数创建动态代理类实例，构造是调用处理器对象作为参数传入</p><p>JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么就无法使用。</p><p>CGLib动态代理：</p><p>利用ASM开源包，对目标对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLib动态代理是通过字节码底层继承目标类来实现的，因此如果目标类被final关键字所修饰，会代理失败。</p><p>CGLib创建的动态代理对象性能比JDK创建的动态代理对象的性能高不少，但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对与单例的对象，因为无需频繁地创建对象，用CGLib比较合适，反之，使用JDK方式要更为合适一些。同时，由于CGLib是采用动态创建子类地方法，对于final修饰的方法，无法进行代理。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
